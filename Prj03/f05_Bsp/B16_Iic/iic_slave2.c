
// ============================================================================
// 函数功能:从机应答函数
// 输入参数:无
// 返 回 值:无
// 备    注:应答函数,保证在两个时钟跳变沿SDA为低,则主机认为是从机应答
// ============================================================================
void ACK(void)
{
    while(!SCL);
    SDA=0;//第9个CLK变高的情况下,SDA输出0
    while(SCL);
    SDA=1;//第9个CLK变低的情况下,SDA输出1
}
// ============================================================================
// 函数功能:初始化函数
// 输入参数:无
// 返 回 值:无
// ============================================================================
void Init(void)
{
    SDA=1;//初始化数据引脚
    SCL=1;//初始化时钟引脚
    EA=1;//开总中断
    IP=0X90;//中断优先级设定,串口>INTO>INT1>T1
    EX0=1;//开外部中断0
}
// ============================================================================
// 函数功能:INT0中断服务程序
// 输入参数:无
// 返 回 值:无
// ============================================================================
void IIC() interrupt0 using0
{
    EX0=0;//关中断
    delay_us(5);
    if(SCL)//真的是Start信号吗?
    {
    //--------------------读取器件地址-------------------------------
        while(SCL);//START时的SCL高电平状态就等待
        for(gg=8;gg>0;gg--)//接收器件地址
        {
            while(!SCL);//SCL低电平状态就等待
            DEVICE_ADR<<1;//高位在前
            if(SDA)
                DEVICE_ADR |= 0x01;//上升沿读取数据位
            while(SCL);//SCL高电平状态就等待
        }
        ACK();//对设备地址ACK应答
    //--------------------以上收到了设备地址,并知晓了主机要对从机进行读还是写操作
        //判断地址是否为0xa0,因为并不是每一次中断进入刚好为start
        if(DEVICE_ADR&0xfe==0xa0)
        {
            //判断数据是读还是写
            if(DEVICE_ADR&0x01)
            {
                
            }
        }
    }
}







